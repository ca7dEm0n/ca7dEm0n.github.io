<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zeKe</title>
    <link>https://a-cat.cn/</link>
    <description>Recent content on zeKe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Jul 2021 10:02:05 +0800</lastBuildDate>
    
	<atom:link href="https://a-cat.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于我</title>
      <link>https://a-cat.cn/posts/about/</link>
      <pubDate>Mon, 19 Jul 2021 10:02:05 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/about/</guid>
      <description>欲目千里，更上一层
 关注领域 运维开发 / 运维监控 / 容器技术 / 网络安全

技能 开发语言: Python / Shell / Rust / JavaScript / Lua 开发框架: Django / Fastapi / Actix / Vue / Element-ui / Flask - 运维服务: Zabbix / Kubernetes / Openresty / Gitlab / Haproxy / Keepalived 等.</description>
    </item>
    
    <item>
      <title>花里胡哨::zshrc每日一个修仙小技巧</title>
      <link>https://a-cat.cn/posts/python/my_zshrc/</link>
      <pubDate>Mon, 20 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/python/my_zshrc/</guid>
      <description>  本文章记录实现一个花里胡哨的终端
 前言 某日，突然想到群里有发过花里胡哨的zshrc终端，闲着无事，也想捣鼓捣鼓。
看过一些效果图，大多都是天气预报、git状态、电脑状态等。
由于平时喜欢修仙，于是方向就有了!
实现 ... 我也懒得详细描述了  #传送门.
效果图 </description>
    </item>
    
    <item>
      <title>openresty使用Lua开发简单功能页面</title>
      <link>https://a-cat.cn/posts/lua/lua_web_page/</link>
      <pubDate>Mon, 16 Mar 2020 10:46:56 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/lua/lua_web_page/</guid>
      <description>本文章记录使用lua开发简单API功能页.
 前言 开发过程中遇到一些特别简单的接口需求，但是单独写一个api接口页面又很麻烦的需求，这个时候可以借助lua来实现.
思路 将简单api功能模块化，统一存放某个路径.
调用时判断模块是否存在，否则返回404.
架构 实现根据字符串加载模块
utils/tools.lua
Tools = { _VERSION = &amp;quot;0.1&amp;quot; } -- 字符切割 function Tools:split(s, p) local rt = {} string.</description>
    </item>
    
    <item>
      <title>Django Rest Framework Image Upload</title>
      <link>https://a-cat.cn/posts/drf/drf_upload/</link>
      <pubDate>Fri, 28 Feb 2020 10:26:10 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/drf/drf_upload/</guid>
      <description>本文章记录在drf框架中实现图片上传功能.
 models.py import os from uuid import uuid4 from datetime import datetime from django.utils import timezone from django.</description>
    </item>
    
    <item>
      <title>Zabbix常用SQL操作</title>
      <link>https://a-cat.cn/posts/ops/zabbix_sql/</link>
      <pubDate>Tue, 14 Jan 2020 23:46:10 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/ops/zabbix_sql/</guid>
      <description>前言 线上API项目中, 有部分常用Zabbix操作, 采用直接读库方式。
 本文章记录出现在项目中的常用SQL操作(主要以3.x版本为例)，主要使用Python语言做演示。
 Zabbix一些对应关系及常量
# 历史表对应ID ZBX_HISTORY_TABLES = (&amp;quot;history&amp;quot;, &amp;quot;history_str&amp;quot;, &amp;quot;history_log&amp;quot;, &amp;quot;history_uint&amp;quot;, &amp;quot;history_text&amp;quot;) # 一些主要的常量 ZBX_MAPPING = { &amp;quot;EVENT_SOURCE_TRIGGERS&amp;quot;: 0, &amp;quot;EVENT_OBJECT_TRIGGER&amp;quot;: 0, &amp;quot;TRIGGER_VALUE_FALSE&amp;quot;: 0, &amp;quot;SEC_PER_DAY&amp;quot;: 86400, &amp;quot;TRIGGER_VALUE_TRUE&amp;quot;: 1, &amp;quot;TRIGGER_VALUE_TRUE&amp;quot;: 0  常用基础操作 获取主机ID # hostname 主机名 def get_host_id(self, hostname): sql = &amp;quot;&amp;quot;&amp;quot; SELECT hg.</description>
    </item>
    
    <item>
      <title>Django Models查库姿势</title>
      <link>https://a-cat.cn/posts/python/django_models/</link>
      <pubDate>Tue, 14 Jan 2020 15:00:04 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/python/django_models/</guid>
      <description>本文章记录django models使用姿势
 datetime时间范围查询 查询今天内的的数据
from datetime import datetime from datetime import time now_datetime = datetime.now() min_datetime = datetime.</description>
    </item>
    
    <item>
      <title>使用Django Rest Framework进行API接口开发</title>
      <link>https://a-cat.cn/posts/drf/drf_develop/</link>
      <pubDate>Mon, 06 Jan 2020 15:47:10 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/drf/drf_develop/</guid>
      <description>本文章记录使用drf框架进行API接口开发
 安装  安装模块  pip install djangorestframework   快速启动项目  # 生成一个名为name的项目 django-admin startproject app # 生成名为api的app django-admin startapp api  引入 settings.</description>
    </item>
    
    <item>
      <title>Logstash处理Nginx中文Post内容乱码</title>
      <link>https://a-cat.cn/posts/elk/logstash_post_body/</link>
      <pubDate>Sat, 04 Jan 2020 19:08:29 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/elk/logstash_post_body/</guid>
      <description>本文章记录采集中有中文字符，出现乱码问题的处理.
 解决 scripts/nginx_request_body.rb
def filter(event) # 设置index日期 event.set(&#39;index_day&#39;, event.timestamp.time.localtime.strftime(&#39;%Y%m%d&#39;)) # 切割message message_array = event.get(&amp;quot;message&amp;quot;).split(&amp;quot;||&amp;quot;) event.set(&amp;quot;host&amp;quot;, message_array[1]) ... # request_body字段 request_body = message_array[13] if request_body.</description>
    </item>
    
    <item>
      <title>Openresty开发采坑记录</title>
      <link>https://a-cat.cn/posts/lua/bug/</link>
      <pubDate>Sat, 04 Jan 2020 18:28:05 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/lua/bug/</guid>
      <description>本文章记录Openresty学习使用过程中碰到的坑.
 #1 打印日志 初学为了直观显示输出,习惯性使用ngx.say调试.
在一开发跳转需求功能的时候发现:
 ngx.say会覆盖ngx.req.set_uri(跳转功能)影响最终结果.
 #2 Redis连接Bad request 为了Redis连接池共用，将Redis连接存储为共享数据.
后续使用断断续续出现Bad request.
查官网后得知真相:
 建议不要使用全局lua变量，并发请求可能会出现因资源竞争导致的请求失败. 传送门</description>
    </item>
    
    <item>
      <title>Vue采坑记录</title>
      <link>https://a-cat.cn/posts/vue/bug/</link>
      <pubDate>Sat, 04 Jan 2020 18:28:00 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/vue/bug/</guid>
      <description>本文章记录Vue学习使用过程中碰到的坑.
 #1 router.options.routes  addRouter无法动态渲染菜单问题.  原因: 根据Vue官网介绍，该路由信息，在创建后不得更改. 传送门
需求场景: 用户登录时根据权限动态渲染菜单，需要读取后添加路由.
解决方案: 遍历路由表，将路由Push到列表内.
// routerList为路由列表 // routerObj为路由对象 for (let i in routerList) { routerObj.</description>
    </item>
    
    <item>
      <title>尝试自己写一个Python缓存装饰器</title>
      <link>https://a-cat.cn/posts/python/python_cache/</link>
      <pubDate>Wed, 15 May 2019 12:49:13 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/python/python_cache/</guid>
      <description>本文记录尝试编写一个简单的缓存装饰器，以学习为目的，实际生产环境建议大家用标准库。
from hashlib import md5 from pickle import dump, load # 用pickle进行数据的读取、写入 def _dkL(f): with open(f,&#39;rb&#39;) as file: return load(file) def _dkD(o,f): with open(f, &#39;wb&#39;) as file: return dump(o,file) def cache(ex_time=10, start=0, have_args=True, have_kw=True, cache_path=&amp;quot;/tmp/pyCache&amp;quot;): # 判断缓存目录是否存在 if not path.</description>
    </item>
    
    <item>
      <title>Django Rest Framework 分页功能与搜索功能</title>
      <link>https://a-cat.cn/posts/drf/drf_pages/</link>
      <pubDate>Wed, 27 Mar 2019 10:25:13 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/drf/drf_pages/</guid>
      <description>本文章记录在drf框架中实现分页、搜索功能.
 实践 分页器 分页器的实现官网介绍有两种方式：
 配置文件配置 继承父类完成自定义分页器  分析分页器源码
自定义分页器主要是继承PageNumberPagination，改写get_paginated_response方法与paginate_queryset方法. &amp;gt; 其中get_paginated_response主要是编写分页器的返回结果.
需求示例：
前端采用iView组件中的分页器，该前端分页器主要接收总页数与当前页数.所以后端需要返回数据，并且返回一个总页数.
class MyPagination(PageNumberPagination): # 指定每一页的个数，默认为配置文件里面的PAGE_SIZE page_size = 10 # 可以让前端指定每页个数，默认为空，这里指定page_size去指定显示个数 page_size_query_param = &#39;page_size&#39; # 可以让前端指定页码数，默认就是page参数去接收 page_query_param = &#39;page&#39; # 指定返回格式，根据需求返回一个总页数，数据存在results字典里返回 def get_paginated_response(self, data): from collections import OrderedDict return Response( OrderedDict([(&#39;count&#39;, self.</description>
    </item>
    
    <item>
      <title>Django Rest Framework JWT鉴权实践</title>
      <link>https://a-cat.cn/posts/drf/drf_jwt/</link>
      <pubDate>Fri, 22 Mar 2019 19:01:13 +0800</pubDate>
      
      <guid>https://a-cat.cn/posts/drf/drf_jwt/</guid>
      <description>本文章记录在drf框架中对JWT鉴权实践过程.
 实践 安装djangorestframework-jwt模块
场景1: 修改默认Username作为用户名验证  改成以uid作为用户名
 settings.py
JWT_PAYLOAD_GET_USERNAME_HANDLER = &#39;uid&#39; # 修改验证后端 AUTHENTICATION_BACKENDS = [ &#39;auth.</description>
    </item>
    
  </channel>
</rss>